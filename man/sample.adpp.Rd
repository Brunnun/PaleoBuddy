% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample.adpp.R
\name{sample.adpp}
\alias{sample.adpp}
\title{Age-dependent rate species sampling}
\usage{
sample.adpp(S = NULL, sim, rr, dFun, dFunMax = NULL, ...)
}
\arguments{
\item{S}{A vector species numbers to be sampled.}

\item{sim}{A \code{sim} object, usually an output of \code{bd.sim}.}

\item{rr}{A mean sampling rate (equivalent to the \code{lambda} of a Poisson)
in the Poisson process.}

\item{dFun}{A density function representing the age-dependent
preservation model. It must be a density function, and consequently

\itemize{

\item integrate to 1 (though this condition is not verified by the function,
it is the user's responsibility to check this property).

\item describe the density of sampling a lineage in a given point \code{t} in
geological time.

\item be parametrized in absolute geological time (i.e. should be relative to
absolute geological time, in Mya).

\item should be limited between \code{s} (i.e. the lineage's
speciation/origination geological time) and \code{e} (i.e. the lineage's 
extinction geological time), with \code{s} > \code{e}.

\item include the arguments \code{t}, \code{s}, \code{e} and \code{sp}.
}}

\item{dFunMax}{A function that calculates the maximum (density) value of
\code{dFun} using its arguments. It can also be a number representing the
maximum density.

Note: if it not provided, it will be approximated numerically, leading to
longer running times.}

\item{...}{Additional parameters related to \code{dFun} and \code{dFunMax}.}
}
\value{
A list of occurrences for that species, expected to be around 
\code{(TS - TE)*rr} occurrences, with their distribution in species relative 
time given by the function provided by the user.
}
\description{
Generates a list of occurrence times for each of the desired species using a
Poisson process with constant average rate and occurrences distributed based on
a model of species age. Allows for any distribution as the model of occurrences
during a species life, given certain requirements (see below). Allows for an
optional argument - the maximum of the distribution - that can make the
simulation faster. Also allows for extra arguments the age-dependent
preservation function may take. For time-varying sampling rates without 
age-dependency, see \code{sample.species}. For a function that unites both
cases and returns an organize data frame, see \code{sample.clade}.
}
\examples{

###
# we can start with a hat-shaped increase through the duration of a species

# simulate a group
sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)

# in case first simulation is short-lived
while ((sim$TS[1] - sim$TE[1]) < 10) {
  sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)
}

# here we will use the PERT function. It is described in:
# Silvestro et al 2014

# preservation function
dPERT <- function(t, s, e, sp, a = 3, b = 3, log = FALSE) {
  
  # check if it is a valid PERT
  if (e >= s) {
    message("There is no PERT with e >= s")
    return(rep(NaN, times = length(t)))
  }
  
  # find the valid and invalid times
  id1 <- which(t <= e | t >= s)
  id2 <- which(!(t <= e | t >= s))
  t <- t[id2]
  
  # initialize result vector
  res <- vector()
  
  # if user wants a log function
  if (log) {
    # invalid times get -Inf
    res[id1] <- -Inf
    
    # valid times calculated with log
    res[id2] <- log(((s - t) ^ 2)*((-e + t) ^ 2)/((s - e) ^ 5*beta(a,b)))
  }
  # otherwise
  else{
    res[id1] <- 0
    
    res[id2] <- ((s - t) ^ 2)*((-e + t) ^ 2)/((s - e) ^ 5*beta(a,b))
  }
  
  return(res)
}

# function to calculate max of the PERT
dPERTmax <- function(s, e, sp) {
  return(((s - e) / 2) + e)
}

# find occurrences
occs <- sample.adpp(S = 1, sim = sim, rr = 1, dFun = dPERT, dFunMax = dPERTmax)

# check histogram
hist(unlist(occs), probability = TRUE)

# expected curve - probably will not fit great because of low sample size, see
# vignettes for more rigorous tests
curve(dPERT(x, s = sim$TS[1], e = sim$TE[1]), 20, 0, add = TRUE, col = "red")

###
# now we can test the simpler scenario of uniform sampling probablity
# through the duration of a species (= homogeneous poisson process)

# simulate a group
sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)

# in case first simulation is short-lived
while ((sim$TS[1] - sim$TE[1]) < 10) {
  sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)
}

# preservation function in respect to age
# occurrences are uniformly distributed
custom.uniform <- function(t, s, e, sp) {
  
  # make sure it is a valid uniform
  if (e >= s) {
    message("There is no uniform function with e >= s")
    return(rep(NaN, times = length(t)))
  }
  
  res <- dunif(x = t, min = e, max = s)
  
  return(res)
}

# we will not give a dFunMax function this time. sample.adpp() will try to find
# the maximum density with a very simple numerical simulation
occs <- sample.adpp(S = 1, sim = sim, rr = 2, dFun = custom.uniform)

# check histogram
hist(unlist(occs[[1]]), probability = TRUE)

# expected curve
curve(dunif (x, min = sim$TE[1], max = sim$TS[1]), 10, 0,
      add = TRUE, col = "red")

###
# now, a hat-shaped increase through the duration of a species with more
# parameters than TS and TE

# simulate a group
sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)

# in case first simulation is short-lived
while ((sim$TS[1] - sim$TE[1]) < 10) {
  sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)
}

# here we will use the triangular distribution. We have some empirical evidence
# that taxa occurrences might present triangular shape
# see Zliobaite et al 2017

# preservation function
dTRI <- function(t, s, e, sp, md) {
  
  # please note ths function is inverted. The correspondence would be:
  # s = b maximum
  # e = a minimum
  # md = c distribution's mode
  
  # make sure it is a valid TRI
  if (e >= s) {
    message("There is no TRI with e >= s")
    return(rep(NaN, times = length(t)))
  }
  
  # another condition we must check
  if (md < e | md > s) {
    message("There is no TRI with md outside [s, e] interval")
    return(rep(NaN, times = length(t)))
  }
  
  # needed to vectorize the function:
  id1 <- which(t >= e & t < md)
  id2 <- which(t == md)
  id3 <- which(t > md & t <= s)
  id4 <- which( !(1:length(t) \%in\% c(id1,id2,id3)))
  
  # actually vetorizing function
  res <- vector()
  
  # (t >= e & t < md)
  res[id1] <- (2*(t[id1] - e)) / ((s - e)*(md - e))
  
  #(t == md)
  res[id2] <- 2 / (s - e)
  
  #(md < t & t <= s)
  res[id3] <- (2*(s - t[id3])) / ((s - e)*(s - md))
  
  #outside function's limits
  res[id4] <- 0
  
  return(res)
}

# the dFunMax function must have the same parameters then the dFun function,
# even if they do not use them
dTRImax <- function(s, e, sp, md) {
  
  return(2 / (s - e))
}

# note we are providing the mode for the triangular sampling as an ... argument
occs <- sample.adpp(S = 1, sim = sim, rr = 2.5, dFun = dTRI,
                   dFunMax = dTRImax, md = 8)

# please note in the original parametrization, the "md" parameter (mode) is
# in "absolute time", i.e. a specific number in the absolute scale. This is not,
# directly, an "age-dependent" model. We show it here as we will construct
# models related to age in the following examples (4 and 5). This is also
# the reason we only plot the first lineage in this specific example
# (many lineages might not be alive in the "md" moment in time).

# check histrogram
hist(unlist(occs[[1]]), probability = TRUE)

# expected curve
curve(dTRI(x, e = sim$TE[1], s = sim$TS[1], md = 8), 10, 0, add = TRUE,
      col = "red")

###
# we can also have a hat-shaped increase through the duration of a species
# with more parameters than TS and TE, but with the parameters relate to
# the relative age of each lineage

# simulate a group
sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)

# in case first simulation is short-lived
while ((sim$TS[1] - sim$TE[1]) < 10) {
  sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)
}

# preservation function, with the "mde" of the triangle being exactly at the
# last quarter of the duration of EACH lineage
dTRImod1 <- function(t, s, e, sp) {
  # note that now we don't have the "md" parameter here,
  # but it is calculated inside the function
  
  # check if it is a valid TRI
  if (e >= s) {
    message("There is no TRI with e >= s")
    return(rep(NaN, times = length(t)))
  }
  
  # calculate md
  md <- ((s - e) / 4) + e
  # md is at the last quarter of the duration of the lineage
  
  # please note that the same logic can be used to sample parameters
  # internally in the function, running for instance:
  # md<-runif (n = 1, min = e, max = s)
  
  # check it is a valid md
  if (md < e | md > s) {
    message("There is no TRI with md outside [s, e] interval")
    return(rep(NaN, times=length(t)))
  }
  
  # needed to vectorize function
  id1 <- which(t >= e & t < md)
  id2 <- which(t == md)
  id3 <- which(t>md & t <= s)
  id4 <- which( !(1:length(t) \%in\% c(id1,id2,id3)))
  
  # vectorize the function
  res<-vector()
  
  res[id1] <- (2*(t[id1] - e)) / ((s - e)*(md - e))
  res[id2] <- 2 / (s - e)
  res[id3] <- (2*(s - t[id3])) / ((s - e)*(s - md))
  res[id4] <- 0
  
  return(res)
}

# function to calculate max
dTRImaxmod1<-function(s, e, sp) {
  return(2 / (s - e))
}

# find occurrences
occs <- sample.adpp(S = 1, sim = sim, rr = 5,
                    dFun = dTRImod1, dFunMax = dTRImaxmod1)

# we do not have the "md" parameter (see example 3) as it corresponds to the
# last quarter of the duration of each lineage

# check histogram
hist(unlist(occs[[1]]), probability = TRUE)

# md of dTRI
mid <- ((sim$TS[1] - sim$TE[1]) / 4) + sim$TE[1]

# expected curve
curve(dTRImod1(x, e = sim$TE[1], s = sim$TS[1]), 10, 0, add = TRUE, 
      col = "red")

###
# finally, a hat-shaped increase through the duration of a species with more
# parameters than TS and TE, but the parameters relate to each specific lineage.
# This is useful when the user wants to use variable parameters for each species
# but wants to keep track of those parameters after the sampling is over

# simulate a group
sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)

# in case first simulation is short-lived
while ((sim$TS[1] - sim$TE[1]) < 10) {
  sim <- bd.sim(n0 = 1, pp = 0.1, qq = 0.1, tMax = 10)
}

# preservation function in respect to age, with the "mode" of the triangle
# being exactly at the last quarter of the duration of EACH lineage.
dTRImod2 <- function(t, s, e, sp) {
  
  # make sure it is a valid TRI
  if (e >= s) {
    message("There is no TRI with e >= s")
    return(rep(NaN, times = length(t)))
  }
  
  # here is the difference from the function in example 3 and 4
  md <- par[sp] + par1[sp]
  
  # check that md is valid
  if (md < e | md > s) {
    message("There is no TRI with md outside [s, e] interval")
    return(rep(NaN, times = length(t)))
  }
  
  id1 <- which(t >= e & t < md)
  id2 <- which(t == md)
  id3 <- which(t > md & t <= s)
  id4 <- which(!(1:length(t) \%in\% c(id1,id2,id3)))
  
  res <- vector()
  
  res[id1] <- (2*(t[id1] - e)) / ((s - e)*(md - e))
  res[id2] <- 2 / (s - e)
  res[id3] <- (2*(s - t[id3])) / ((s - e)*(s - md))
  res[id4] <- 0
  
  return(res)
  #for more details in this function, see example 3 and 4
}

# maximum function
dTRImaxmod2 <- function(s, e, sp) {
  return(2 / (s - e))
}

# get the par and par1 vectors
par <- runif (n = length(sim$TE), min = sim$TE, max = sim$TS)
par1 <- (((sim$TS - sim$TE)/2) + sim$TE) - par

# find occurrence list
occs <- sample.adpp(S = 1:length(sim$TE), sim = sim, rr = 10,
                    dFun = dTRImod2, dFunMax = dTRImaxmod2)

# we do not have the "md" parameter (see example 3) as it corresponds to
# the last quarter of the duration of each lineage

# checking each species
for (sp in 1:length(sim$TE)) {
  # check histogram
  hist(unlist(occs[[sp]]), probability = TRUE,
       main = paste0("spp ", sp, " ; duration ~ ",
                     round(sim$TS[sp] - sim$TE[sp], digits = 2)))
  
  # calculate mid
  mid <- par[sp] + par1[sp]
  
  # expected curve
  curve(dTRImod2(x, e = sim$TE[sp], s = sim$TS[sp], sp), 10, 0, add = TRUE,
        col = "red", n = 100)
  abline(v = mid, col = "red")
}

}
\author{
Matheus Januario.
}
