% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make.rate.R
\name{make.rate}
\alias{make.rate}
\title{Create a flexible rate for birth-death or sampling simulations}
\usage{
make.rate(ff, tMax = NULL, envF = NULL, fShifts = NULL)
}
\arguments{
\item{ff}{The baseline function with which to make the rate.
It can be a

\describe{
\item{\code{Constant}}{For constant birth-death rates.}

\item{\code{Function of time}}{For rates that vary with time. Note that this
can be any function of time, but one should not supply a function that
depends on more than one variable without an accompanying \code{envF} -
that will result in an error.}

\item{\code{Vector of rates}}{To create step function rates. Note this must
be accompanied by a corresponding vector of shifts \code{fShifts}.}}}

\item{tMax}{A number corresponding to the maximum simulation time.
Needed to ensure \code{fShifts} runs the correct way.}

\item{envF}{A matrix representing an environmental variable (time, CO2, etc)
with time. The first column must be time, second column the values of the 
variable. Note that supplying \code{envF} with \code{ff} being a function of
only one variable or a constant results in an error.}

\item{fShifts}{A vector of rate shifts. The first element must
be the first time point for the simulation. This may be \code{0} or 
\code{tMax}. Since functions in paleobuddy run from \code{0} to \code{tMax}, if
\code{fShifts} runs from past to present (\code{fShifts[2] < fShifts[1]}), we 
take \code{tMax - fShifts} as the shifts vector. Note that supplying 
\code{fShifts} when \code{ff} is not a rates vector will result in an error.}
}
\value{
A constant or time-varying function (depending on input) that can
then be used as a rate in the other \code{paleobuddy} functions. The returned
function will invariably be either a number or a function of one variable only, 
usually set as time.
}
\description{
Generates a rate to be used on birth-death or sampling functions. Takes as the
base rate a constant, function of time, function of time and an environmental
variable or a vector of numbers. Allows for modifying using a vector of rate 
shift times or a matrix containing time and environmental data. Also requires
\code{tMax}, the maximum simulation time, so it can recognize both forward and
backward time vector rates.
}
\examples{

# first we need a time vector to use on plots
t <- seq(0, 50, 0.1)

# make.rate will leave some types of functions unaltered, like the following

###
# let us start simple: create a constant rate
r <- make.rate(0.5)

# plot it
plot(t, rep(r, length(t)), type = 'l')

###
# something a bit more complex: a linear rate

# function
ff <- function(t) {
  return(0.01*t)
}

# create rate
r <- make.rate(ff)

# plot it
plot(t, r(t), type = 'l')

###
# remember: this can be any time-varying function!

# function
ff <- function(t) {
  return(sin(t)*0.01)
}

# create rate
r <- make.rate(ff)

# plot it
plot(t, r(t), type = 'l')

###
# we can use ifelse() to make a step function like this
ff <- function(t) {
  return(ifelse(t < 10, 0.1,
                ifelse(t < 20, 0.3,
                       ifelse(t < 30, 0.2,
                              ifelse(t < 40, 0.05, 0)))))
}

# and make it into a rate - in this case, as the previous, it does not alter
# ff. We put it here as a contrast to the other way to make a step function
r <- make.rate(ff)

# plot it
plot(t, r(t), type = 'l')

# important note: this method of creating a step function might be annoying,
# but when running thousands of simulations it will provide a much faster
# integration than when using our method of transforming a rates and shifts
# vector into a function of time

# this is a good segway into the cases where make.rate actually makes a rate!
# note that while the previous ones seemed useless, we need that implementation
# so that the birth-death functions work

###
# now we can demonstrate the other way of making a step function

# vector of rates
ff <- c(0.1, 0.2, 0.3, 0.2)

# vector of rate shifts
fShifts <- c(0, 10, 20, 35)
# this could be c(50, 40, 30, 15) for equivalent results

# make the rate
r <- make.rate(ff, tMax = 50, fShifts = fShifts)

# plot it
plot(t, r(t),type = 'l')

# as mentioned above, while this works well it will be a pain to integrate.
# Furthermore, it is impractical to supply a rate and a shifts vector and
# have an environmental dependency, so in cases where one looks to run
# more than a couple dozen simulations, or when one is looking to have a
# step function modified by an environmental variable, consider using ifelse()

###
# finally let us see what we can do with environmental variables

# RPANDA supplies us with some really useful environmental dataframes
# to use as an example, let us try temperature
if (requireNamespace("RPANDA", quietly = TRUE)) {
  # temperature data
  data(InfTemp, package = "RPANDA")
  
  # function
  ff <- function(t, env) {
    return(0.05*env)
  }
  
  # make the rate
  r <- make.rate(ff, envF = InfTemp)
  
  # plot it
  plot(t, r(t), type = 'l')
  
  ###
  # we can also have a function that depends on both time AND temperature
  
  # function
  ff <- function(t, env) {
    return(0.001*exp(0.1*t) + 0.05*env)
  }
  
  # make a rate
  r <- make.rate(ff, envF = InfTemp)
  
  # plot it
  plot(t, r(t), type = 'l')
  
  ###
  # as mentioned above, we could also use ifelse() to construct a step function
  # that is modulated by temperature
  
  # function
  ff <- function(t, env) {
    return(ifelse(t < 10, 0.1 + 0.01*env,
                  ifelse(t < 30, 0.2 - 0.005*env,
                         ifelse(t <= 50, 0.1 + 0.005*env, 0))))
  }
  
  # rate
  r <- make.rate(ff, envF = InfTemp)
  
  # plot it
  plot(t, r(t), type = 'l')
}

}
\author{
Bruno do Rosario Petrucci
}
