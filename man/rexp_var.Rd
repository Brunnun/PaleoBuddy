% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rexp_var.R
\name{rexp_var}
\alias{rexp_var}
\title{General rate exponential and Weibull waiting times}
\usage{
rexp_var(n = 1, lambda, now, tMax, shape = NULL, TS = NULL, fast = TRUE)
}
\arguments{
\item{n}{the number of waiting times to return. The default is 1, but we
allow for a higher \code{n} to be consistent with the \code{rexp} function.}

\item{lambda}{the rate parameter for the exponential
distribution. If shape is not \code{NULL}, \code{lambda} is a scale for a
Weibull distribution. In both cases we allow for any time-varying function. 
If one wants a constant \code{c}, please use 
\code{lambda <- Vectorize(function(t) c)}.}

\item{now}{the current time. Needed so that we consider only the interval
between the current time and the maximum time for the time-varying rate.
Notice this does means the waiting time is \code{>= now}, so we also
subtract \code{now} from the result before returning.}

\item{tMax}{the simulation ending time. If the waiting time would be too
high, we return \code{2*tMax} to signify the event never happens, if 
\code{FAST == TRUE}. The function only considers the rate between \code{now}
and \code{tMax}.}

\item{shape}{the shape of a weibull distribution. If not \code{NULL}, the 
distribution dis taken to be a weibull. Otherwise, it is considered an
exponential.

Notes: if \code{shape} is really low it may be impossible
for \code{uniroot} to find a root; Time-varying shape is implemented, but
not yet thoroughly tested.}

\item{TS}{if shape is given, there must be a \code{TS} parameter to account
for the scaling between simulation and species time. Supplying one without
the other leads to an error.}

\item{fast}{if set to \code{FALSE}, waiting times larger than \code{tMax} 
will not be thrown away. This argument is needed so one can testt he function
without bias.}
}
\value{
a vector of waiting times for the exponential or weibull
distribution with the given rates.
}
\description{
\code{rexp_var} uses a rate (that could be constant or time-varying), a range
of time and optionally a shape for age dependent rates. It also takes a
number of waiting times to return, and whether the user wishes to throw away
waiting times that pass \code{tMax}. It returns a time from an exponential
distribution, or a weibull distribution if \code{shape != NULL}.
}
\examples{

# Note: to effectively test, you must pass \code{fast=FALSE} to the function.

# use the \code{fitdistrplus} package to see if our distributions fit what
# we expect
if (requireNamespace("fitdistrplus", quietly = TRUE)) {
  # let us start by checking a simple exponential variable
  
  # rate
  lambda <- 0.1
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 10000, lambda, now, tMax, fast = FALSE)
  
  # find rate
  rate <- unname(fitdistrplus::fitdist(dis, distr = "exp")$estimate)
  
  # check
  print(paste("rate: ", paste(rate, paste(", expected: ", lambda))))
}
  
  # another simple exponential
  
  # rate
  lambda <- 0.5
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 10000, lambda, now, tMax, fast = FALSE)
  
  # find rate
  rate <- unname(fitdistrplus::fitdist(dis, distr = "exp")$estimate)
  
  # check
  print(paste("rate: ", paste(rate, paste(", expected: ", lambda))))
}
  
  # now let us try a linear function
  
  # rate
  lambda <- function(t) {
    return(0.01*t + 0.1)
  }
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 10000, lambda, now, tMax, fast = FALSE)
  
  # find the rate
  rate <- unname(fitdistrplus::fitdist(dis, distr = "exp")$estimate)
  
  # we can integrate to find the mean rate
  
  # the integrate of 1/this is the mean rate
  f <- Vectorize(function(t) {
    ifelse(lambda(t) == Inf, 0,
           exp(-integrate(function(x) lambda(x),
                          lower = 0, upper = t, subdivisions = 2000)$value))})
  
  # calculate the mean
  mean <- 1/integrate(f, 0, Inf)$value
  
  # check
  print(paste("rate: ", paste(rate, paste(", expected: ", mean))))
  
  # and we can also integrate to find the mean directly
  
  # get distribution function
  p <- Vectorize(function(t) {
    return(
      ifelse(lambda(t) == Inf, 0,
             lambda(t)*exp(-integrate(Vectorize(
               function(x) lambda(x)), lower = 0, upper = t)$value))
    )
  })
  
  # integrate it on the whole space
  mean<-integrate(function(t) t*p(t), 0, Inf)$value
  
  # check
  print(paste("mean: ", paste(mean(dis), paste(", expected: ", mean))))
}
  
  # what if lambda is exponential?
  
  # rate
  lambda <- function(t) {
    return(0.01 * exp(0.1*t) + 0.02)
  }
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 10000, lambda, now, tMax, fast = FALSE)
  
  # we can integrate to find the mean rate
  
  # the integrate of 1/this is the mean rate
  f <- Vectorize(function(t) {
    ifelse(lambda(t) == Inf, 0,
           exp(-integrate(function(x) lambda(x),
                          lower = 0, upper = t, subdivisions = 2000)$value))})
  
  # calculate the mean
  mean <- 1/integrate(f, 0, Inf)$value
  
  # check
  print(paste("rate: ", paste(rate, paste(", expected: ", mean))))
  
  # and we can also integrate to find the mean directly
  
  # get distribution function
  p <- Vectorize(function(t) {
    return(
      ifelse(lambda(t) == Inf, 0,
             lambda(t)*exp(-integrate(Vectorize(
               function(x) lambda(x)), lower = 0, upper = t)$value))
    )
  })
  
  # integrate it on the whole space
  mean<-integrate(function(t) t*p(t), 0, Inf)$value
  
  # check
  print(paste("mean: ", paste(mean(dis), paste(", expected: ", mean))))
}
  
  # now we can also test the age dependency
  
  # scale
  lambda <- 2
  
  # shape
  shape <- 1
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 5000, lambda, now, tMax, 
                  shape = shape, TS = 0, fast = FALSE)
  
  # find the estimates
  
  # shape
  eShape <- unname(fitdistrplus::fitdist(dis, distr = "weibull")$estimate)[1]
  
  # scale
  eScale <- unname(fitdistrplus::fitdist(dis, distr = "weibull")$estimate)[2]
  
  # check
  print(paste("shape: ", paste(eShape, paste(", expected: ", shape))))
  print(paste("scale: ", paste(eScale, paste(", expected: ", lambda))))
  
}
  
  # shape = 1 is an exponential, we could do better
  
  # scale
  lambda <- 10
  
  # shape
  shape <- 2
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{   
  # find the list of waiting times
  dis <- rexp_var(n = 5000, lambda, now, tMax, 
                  shape = shape, TS = 0, fast = FALSE)
  
  # find the estimates
  
  # shape
  eShape <- unname(fitdistrplus::fitdist(dis, distr = "weibull")$estimate)[1]
  
  # scale
  eScale <- unname(fitdistrplus::fitdist(dis, distr = "weibull")$estimate)[2]
  
  # check
  print(paste("shape: ", paste(eShape, paste(", expected: ", shape))))
  print(paste("scale: ", paste(eScale, paste(", expected: ", lambda))))
}
  
  # fitdist gets a bit weird with shape less than 1,
  # so we need some extra arguments to get a fit
  
  # scale
  lambda <- 10
  
  # shape
  shape <- 0.5
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n=10000, lambda, now, tMax, 
                  shape = shape, TS = 0, fast = FALSE)
  
  # find the estimates
  
  # shape
  eShape <- unname(fitdistrplus::fitdist(dis, distr = "weibull",
                                         start = list(shape = 1, scale = 1),
                                         method = "mge", gof = "CvM")$estimate)[1]
  
  # scale
  eScale <- unname(fitdistrplus::fitdist(dis, distr = "weibull",
                                         start = list(shape = 1, scale = 1),
                                         method = "mge", gof = "CvM")$estimate)[2]
  
  # check
  print(paste("shape: ", paste(eShape, paste(", expected: ", shape))))
  print(paste("scale: ", paste(eScale, paste(", expected: ", lambda))))
}
  
  # when lambda varies, we might need to do some more to test
  
  # scale
  lambda <- function(t) {
    return(0.25*t + 5)
  }
  
  # shape
  shape <- 3
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 5000, lambda, now, tMax, 
                  shape = shape, TS = 0, fast = FALSE)
  
  # we will integrate the distribution to find the mean directly
  
  # distribution function
  p <- Vectorize(function(t) {
    res<-shape/lambda(t)*(integrate(
      Vectorize(function(x) 1/lambda(x)), lower = 0, upper = t,
      subdivisions = 2000)$value) ^ (shape - 1)*
      exp(-(integrate(Vectorize(function(x) 1/lambda(x)), 0, t,
                      subdivisions = 2000)$value)^shape)
    # na simply means R doesn't know how to multiply 0 by infinity, but we just
    # need to make it 0 since t*exp(-t) goes to 0 when t goes to infinity
    return(res)
  })
  
  # find the mean
  mean <- integrate(function(t) t*p(t), 0, Inf)$value
  
  # check
  print(paste("rate: ", paste(mean(dis), paste(", expected: ", mean))))
}
  
  # lambda can be any function of time, remember
  
  # scale
  lambda <- function(t) {
    return(0.2*exp(0.1*t) + 5)
  }
  
  # shape
  shape <- 3
  
  # current time
  now <- 0
  
  # maximum time to check 
  tMax <- 40
  
\dontrun{
  # find the list of waiting times
  dis <- rexp_var(n = 5000, lambda, now, tMax, 
                  shape = shape, TS = 0, fast = FALSE)
  
  # we will integrate the distribution to find the mean directly
  
  # distribution function
  p <- Vectorize(function(t) {
    res<-shape/lambda(t)*(integrate(
      Vectorize(function(x) 1/lambda(x)), lower = 0, upper = t,
      subdivisions = 2000)$value) ^ (shape-1)*
      exp(-(integrate(Vectorize(function(x) 1/lambda(x)), 0, t,
                      subdivisions = 2000)$value) ^ shape)
    # na simply means R doesn't know how to multiply 0 by infinity, but we just
    # need to make it 0 since t*exp(-t) goes to 0 when t goes to infinity
    return(ifelse(is.na(res), 0, res))
  })
  
  # find the mean
  mean <- integrate(function(t) t*p(t), 0, Inf)$value
  
  # check
  print(paste("rate: ", paste(mean(dis), paste(", expected: ", mean))))
}
}

}
\author{
written by Bruno do Rosario Petrucci.
}
