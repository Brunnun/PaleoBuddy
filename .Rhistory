#'
#' @author written by Matheus Januario.
#'
#' @examples
#'
#' this function is simple to test: let us just create an artificial bin and occurrence lists and then check it bounds them correctly
x1 <- c(5.2, 4.9, 4.1, 3.2, 1, 0.2)
bins1 <- c(6, 5, 4, 3, 2, 1, 0)
binneredSamp1 <- binner(x1, bins1) # should be (1, 2, 1, 0, 1, )
binneredSamp1
binner<-function(x, bins){
# create result
res<-vector()
# in case time was passed wrong
bins <- sort(bins, decreasing=T)
x <- sort(x, decreasing=T)
# for each bin,
for(i in 2:(length(bins)-1)){
# get the occurrences before this bin and after previous
res<-c(res, sum(x<bins[i-1] & x>=bins[i]))
}
# find the last one
i<-length(bins)
res<-c(res, sum(x<bins[i-1] & x>=bins[i]))
return(res)
}
#' @param \code{x} the list containing occurrence times for a given species.
#' @param \code{bins} a vector of time intervals corresponding to geological time ranges.
#'
#' @return a list of upper bounds for the occurrence times of a species.
#'
#' @author written by Matheus Januario.
#'
#' @examples
#'
#' this function is simple to test: let us just create an artificial bin and occurrence lists and then check it bounds them correctly
x1 <- c(5.2, 4.9, 4.1, 3.2, 1, 0.2)
bins1 <- c(6, 5, 4, 3, 2, 1, 0)
binneredSamp1 <- binner(x1, bins1) # should be (1, 2, 1, 0, 1, 1)
binneredSamp1
#'
#' it should work with any type of number in IntVec
x2 <- c(6.7, 5.03, 4.2, 3.4, 1.2, 0.4)
bins2 <- c(7, bins1)
bins2 <- binner(x2, bins2) # should be (0.4, 1.2, 3.4, 4.2, 5.03, 6.7)
bins2 <- binner(x2, bins2) # should be (1, 1, 1, 1, 0, 1, 1)
#'
#' it should work with any type of number in IntVec
x2 <- c(6.7, 5.03, 4.2, 3.4, 1.2, 0.4)
bins2 <- c(7, bins1)
bineredSamp2 <- binner(x2, bins2) # should be (1, 1, 1, 1, 0, 1, 1)
binneredSamp1
binneredSamp2
binneredSamp2 <- binner(x2, bins2) # should be (1, 1, 1, 1, 0, 1, 1)
binneredSamp2
#'
#' let us try with a real simulated species fossil record
sim <- BDSim(1, 0.1, 0.09, 50)
sampled1 <- Sample(1, sim$TE, sim$TS, 1, 50)
#'
#' let us try with a real simulated species fossil record
sim <- BDSim(1, 0.1, 0.09, 50)
sampled1 <- Sample(1, sim$TE, sim$TS, 1, 50)
bins3 <- c(15.1, 12.3, 10, 7.1, 5.8, 3.4, 2.2, 0)
binneredSample <- binner(sampled1, bins3)
binneredSample
sim
sampled1
#'
#' let us try with a real simulated species fossil record
sim <- BDSim(1, 0.1, 0.09, 15)
sampled1 <- Sample(1, sim$TE, sim$TS, 1, 15)
bins3 <- c(15.1, 12.3, 10, 7.1, 5.8, 3.4, 2.2, 0)
binneredSample <- binner(sampled1, bins3)
binneredSample
sampled1
sampled1 <- Sample(1, sim$TE, sim$TS, 1, 15)
sampled1
binneredSample <- binner(sampled1, bins3)
binneredSample
binner<-function(x, bins){
# create result
res<-vector()
# in case time was passed wrong
bins <- sort(bins, decreasing=T)
x <- sort(x, decreasing=T)
# for each bin,
for(i in 2:(length(bins)-1)){
# get the occurrences before this bin and after previous
res<-c(res, sum(x<bins[i-1] & x>=bins[i]))
}
# find the last one
i<-length(bins)
res<-c(res, sum(x<bins[i-1] & x>=bins[i]))
return(res)
}
return(env)
#'
#' finally, \code{SampleClade} also accepts an environmental variable
library(RPANDA)
data(InfTemp)
#'
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
while((sim$TS[1]-sim$TE[1])<10){ # in case first simulation has short-lived lineage which will obscure the pattern
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
}
#'
env_r <- InfTemp
r <- function(t, env) {
return(env)
}
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
r <- MakeRate(rlist, 10, fshifts=rshifts)
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
r <- MakeRate(r, env_f=env_r)
r <- function(t, env) {
return(env)
}
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
r <- MakeRate(r, env_f=env_r)
plot(1:10, r(1:10))
r <- function(t, env) {
return(25*env)
}
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
r <- MakeRate(r, env_f=env_r)
#' let us check r is high enough to see a pattern
plot(1:10, r(1:10), type='l', main="Sampling rate", xlab="My", ylab="r")
#' the resolution of the fossil dataset:
stages=seq(from=10, to = 0, # from simulation's tmax to present
by = -.1) # note that we will provide a very high resolution (= 0.1 My) just to test the function:
#'
dt<-SampleClade(1:length(sim$TE), sim, rlist, tmax=10, rshifts=rshifts, stages=stages)
ids<-unique(dt$Species)
mids<-(dt$MaxT-dt$MinT)+dt$MinT
#'
for(i in 1:length(ids)){
sp<-unique(as.numeric(gsub("spp_", "", ids[i])))
hist(mids[dt$Species==ids[i]], main=paste0("spp = ", sp, "; duration ~ ", round(sim$TS[sp]-sim$TE[sp], digits = 2), "my"),
xlab="My", breaks=seq(round(sim$TS[i]), round(sim$TE[i]), -1), xlim=c(sim$TS[i], sim$TE[i]))
mid=par[sp]
t <- seq(sim$TE[i], sim$TS[i], 0.1)
lines(t, rev(r(t)))
}
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
while((sim$TS[1]-sim$TE[1])<10){ # in case first simulation has short-lived lineage which will obscure the pattern
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
}
#'
env_r <- InfTemp
r <- function(t, env) {
return(25*env)
}
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
rr <- MakeRate(r, env_f=env_r)
#' let us check r is high enough to see a pattern
plot(1:10, rr(1:10), type='l', main="Sampling rate", xlab="My", ylab="r")
#' the resolution of the fossil dataset:
stages=seq(from=10, to = 0, # from simulation's tmax to present
by = -.1) # note that we will provide a very high resolution (= 0.1 My) just to test the function:
#'
dt<-SampleClade(1:length(sim$TE), sim, r, tmax=10, env_rr=env_r, stages=stages)
ids<-unique(dt$Species)
mids<-(dt$MaxT-dt$MinT)+dt$MinT
#'
for(i in 1:length(ids)){
sp<-unique(as.numeric(gsub("spp_", "", ids[i])))
hist(mids[dt$Species==ids[i]], main=paste0("spp = ", sp, "; duration ~ ", round(sim$TS[sp]-sim$TE[sp], digits = 2), "my"),
xlab="My", breaks=seq(round(sim$TS[i]), round(sim$TE[i]), -1), xlim=c(sim$TS[i], sim$TE[i]))
mid=par[sp]
t <- seq(sim$TE[i], sim$TS[i], 0.1)
lines(t, rev(r(t)))
}
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
while((sim$TS[1]-sim$TE[1])<10){ # in case first simulation has short-lived lineage which will obscure the pattern
sim<-BDSim(N0 = 1, pp = .1, qq = 0.1, tmax = 10)
}
#'
env_r <- InfTemp
r <- function(t, env) {
return(25*env)
}
#' this makes the simulation slower than when using \code{ifelse} to make a stepfunction, but it is an option
#' make it a function so we can plot it
rr <- MakeRate(r, env_f=env_r)
#' let us check r is high enough to see a pattern
plot(1:10, rr(1:10), type='l', main="Sampling rate", xlab="My", ylab="r")
#' the resolution of the fossil dataset:
stages=seq(from=10, to = 0, # from simulation's tmax to present
by = -.1) # note that we will provide a very high resolution (= 0.1 My) just to test the function:
#'
dt<-SampleClade(1:length(sim$TE), sim, r, tmax=10, env_rr=env_r, stages=stages)
ids<-unique(dt$Species)
mids<-(dt$MaxT-dt$MinT)+dt$MinT
#'
for(i in 1:length(ids)){
sp<-unique(as.numeric(gsub("spp_", "", ids[i])))
hist(mids[dt$Species==ids[i]], main=paste0("spp = ", sp, "; duration ~ ", round(sim$TS[sp]-sim$TE[sp], digits = 2), "my"),
xlab="My", breaks=seq(round(sim$TS[i]), round(sim$TE[i]), -1), xlim=c(sim$TS[i], sim$TE[i]))
mid=par[sp]
t <- seq(sim$TE[i], sim$TS[i], 0.1)
lines(t, rev(rr(t)))
}
SampleClade<-function(S, sim, rr,tmax,env_rr=NULL,rshifts=NULL,returnTrue=FALSE,stages=NULL, dFUN=NULL, dFUNmax=NULL,...){
# get the speciation and extinction times vectors
TE <- sim$TE[S]
TS <- sim$TS[S]
# check if it is age-dependent
if(is.null(dFUN)){
rr <- MakeRate(rr, tmax, env_rr, rshifts)
} else{
if(!is.numeric(rr) | length(rr)>1){
stop("ADPP cannot be used with time-varing preservation rates")
}
}
# adjusting stages
stages<-sort(stages, decreasing = T)
# sample using Poisson process:
if(is.null(dFUN)){ # independent of age (i.e. occurrences uniformly distributed through the lineage's age)
point_estimates<-lapply(S,Sample,TE=TE,TS=TS,rr=rr,tmax=tmax)
} else{ #dependent of age (i.e. occurrences distributed through the lineage's age accourding to the function provided by the user)
point_estimates<-SampleADPP(S, TS=TS, TE=TE, rr=rr, dFUN = dFUN, dFUNmax = dFUNmax, ...)
}
#wrapping data:
if(!returnTrue){ # output as fossil occurrence binned within stages/bins
res<-data.frame(matrix(nrow=0, ncol=4))
colnames(res)<-c("Species", "Extant", "MaxT", "MinT")
for(i in 1:length(point_estimates)){
binned_occs<-binner(point_estimates[[i]], bins=stages)
for(k in 1:(length(stages)-1)){
if(binned_occs[k]>0){
# make a row of the data frame
aux<-data.frame(Species=i,Extant=NA,MaxT=rep(stages[k], times=binned_occs[k]),MinT=stages[k+1])
res<-rbind(res, aux)
}
}
}
# make the Extant column
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
# and the species column
res$Species<-paste0("spp_", res$Species)
} else{ # output as the "true" times of preservation of each lineage
# if returnTrue=TRUE, get a a data frame with the real sampling times only
res<-data.frame(matrix(nrow=0, ncol=3))
colsnames(res)<-c("Species", "Extant", "SampT")
res$Species<-rep(S, times=lapply(point_estimates, length))
res$Species<-paste0("spp_", res$Species)
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
}
return(res)
}
sim
SampleClade(1, sim, 100, returnTrue=TRUE)
SampleClade(1, sim, 100, tmax=10, returnTrue=TRUE)
SampleClade<-function(S, sim, rr,tmax,env_rr=NULL,rshifts=NULL,returnTrue=FALSE,stages=NULL, dFUN=NULL, dFUNmax=NULL,...){
# get the speciation and extinction times vectors
TE <- sim$TE[S]
TS <- sim$TS[S]
# check if it is age-dependent
if(is.null(dFUN)){
rr <- MakeRate(rr, tmax, env_rr, rshifts)
} else{
if(!is.numeric(rr) | length(rr)>1){
stop("ADPP cannot be used with time-varing preservation rates")
}
}
# adjusting stages
stages<-sort(stages, decreasing = T)
# sample using Poisson process:
if(is.null(dFUN)){ # independent of age (i.e. occurrences uniformly distributed through the lineage's age)
point_estimates<-lapply(S,Sample,TE=TE,TS=TS,rr=rr,tmax=tmax)
} else{ #dependent of age (i.e. occurrences distributed through the lineage's age accourding to the function provided by the user)
point_estimates<-SampleADPP(S, TS=TS, TE=TE, rr=rr, dFUN = dFUN, dFUNmax = dFUNmax, ...)
}
#wrapping data:
if(!returnTrue){ # output as fossil occurrence binned within stages/bins
res<-data.frame(matrix(nrow=0, ncol=4))
colnames(res)<-c("Species", "Extant", "MaxT", "MinT")
for(i in 1:length(point_estimates)){
binned_occs<-binner(point_estimates[[i]], bins=stages)
for(k in 1:(length(stages)-1)){
if(binned_occs[k]>0){
# make a row of the data frame
aux<-data.frame(Species=i,Extant=NA,MaxT=rep(stages[k], times=binned_occs[k]),MinT=stages[k+1])
res<-rbind(res, aux)
}
}
}
# make the Extant column
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
# and the species column
res$Species<-paste0("spp_", res$Species)
} else{ # output as the "true" times of preservation of each lineage
# if returnTrue=TRUE, get a a data frame with the real sampling times only
res<-data.frame(matrix(nrow=0, ncol=3))
colnames(res)<-c("Species", "Extant", "SampT")
res$Species<-rep(S, times=lapply(point_estimates, length))
res$Species<-paste0("spp_", res$Species)
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
}
return(res)
}
SampleClade(1, sim, 100, tmax=10, returnTrue=TRUE)
SampleClade<-function(S, sim, rr,tmax,env_rr=NULL,rshifts=NULL,returnTrue=FALSE,stages=NULL, dFUN=NULL, dFUNmax=NULL,...){
# get the speciation and extinction times vectors
TE <- sim$TE[S]
TS <- sim$TS[S]
# check if it is age-dependent
if(is.null(dFUN)){
rr <- MakeRate(rr, tmax, env_rr, rshifts)
} else{
if(!is.numeric(rr) | length(rr)>1){
stop("ADPP cannot be used with time-varing preservation rates")
}
}
# adjusting stages
stages<-sort(stages, decreasing = T)
# sample using Poisson process:
if(is.null(dFUN)){ # independent of age (i.e. occurrences uniformly distributed through the lineage's age)
point_estimates<-lapply(S,Sample,TE=TE,TS=TS,rr=rr,tmax=tmax)
} else{ #dependent of age (i.e. occurrences distributed through the lineage's age accourding to the function provided by the user)
point_estimates<-SampleADPP(S, TS=TS, TE=TE, rr=rr, dFUN = dFUN, dFUNmax = dFUNmax, ...)
}
#wrapping data:
if(!returnTrue){ # output as fossil occurrence binned within stages/bins
res<-data.frame(matrix(nrow=0, ncol=4))
colnames(res)<-c("Species", "Extant", "MaxT", "MinT")
for(i in 1:length(point_estimates)){
binned_occs<-binner(point_estimates[[i]], bins=stages)
for(k in 1:(length(stages)-1)){
if(binned_occs[k]>0){
# make a row of the data frame
aux<-data.frame(Species=i,Extant=NA,MaxT=rep(stages[k], times=binned_occs[k]),MinT=stages[k+1])
res<-rbind(res, aux)
}
}
}
# make the Extant column
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
# and the species column
res$Species<-paste0("spp_", res$Species)
} else{ # output as the "true" times of preservation of each lineage
# if returnTrue=TRUE, get a a data frame with the real sampling times only
res<-data.frame(matrix(nrow=length(point_estimates), ncol=3))
colnames(res)<-c("Species", "Extant", "SampT")
res$Species<-rep(S, times=lapply(point_estimates, length))
res$Species<-paste0("spp_", res$Species)
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
}
return(res)
}
SampleClade(1, sim, 100, tmax=10, returnTrue=TRUE)
SampleClade<-function(S, sim, rr,tmax,env_rr=NULL,rshifts=NULL,returnTrue=FALSE,stages=NULL, dFUN=NULL, dFUNmax=NULL,...){
# get the speciation and extinction times vectors
TE <- sim$TE[S]
TS <- sim$TS[S]
# check if it is age-dependent
if(is.null(dFUN)){
rr <- MakeRate(rr, tmax, env_rr, rshifts)
} else{
if(!is.numeric(rr) | length(rr)>1){
stop("ADPP cannot be used with time-varing preservation rates")
}
}
# adjusting stages
stages<-sort(stages, decreasing = T)
# sample using Poisson process:
if(is.null(dFUN)){ # independent of age (i.e. occurrences uniformly distributed through the lineage's age)
point_estimates<-lapply(S,Sample,TE=TE,TS=TS,rr=rr,tmax=tmax)
} else{ #dependent of age (i.e. occurrences distributed through the lineage's age accourding to the function provided by the user)
point_estimates<-SampleADPP(S, TS=TS, TE=TE, rr=rr, dFUN = dFUN, dFUNmax = dFUNmax, ...)
}
#wrapping data:
if(!returnTrue){ # output as fossil occurrence binned within stages/bins
res<-data.frame(matrix(nrow=0, ncol=4))
colnames(res)<-c("Species", "Extant", "MaxT", "MinT")
for(i in 1:length(point_estimates)){
binned_occs<-binner(point_estimates[[i]], bins=stages)
for(k in 1:(length(stages)-1)){
if(binned_occs[k]>0){
# make a row of the data frame
aux<-data.frame(Species=i,Extant=NA,MaxT=rep(stages[k], times=binned_occs[k]),MinT=stages[k+1])
res<-rbind(res, aux)
}
}
}
# make the Extant column
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
# and the species column
res$Species<-paste0("spp_", res$Species)
} else{ # output as the "true" times of preservation of each lineage
# if returnTrue=TRUE, get a a data frame with the real sampling times only
res<-data.frame(matrix(nrow=length(unlist(point_estimates)), ncol=3))
colnames(res)<-c("Species", "Extant", "SampT")
res$Species<-rep(S, times=lapply(point_estimates, length))
res$Species<-paste0("spp_", res$Species)
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
}
return(res)
}
SampleClade(1, sim, 100, tmax=10, returnTrue=TRUE)
sim
sim$EXTANT
SampleClade<-function(S, sim, rr,tmax,env_rr=NULL,rshifts=NULL,returnTrue=FALSE,stages=NULL, dFUN=NULL, dFUNmax=NULL,...){
# get the speciation and extinction times vectors
TE <- sim$TE[S]
TS <- sim$TS[S]
# check if it is age-dependent
if(is.null(dFUN)){
rr <- MakeRate(rr, tmax, env_rr, rshifts)
} else{
if(!is.numeric(rr) | length(rr)>1){
stop("ADPP cannot be used with time-varing preservation rates")
}
}
# adjusting stages
stages<-sort(stages, decreasing = T)
# sample using Poisson process:
if(is.null(dFUN)){ # independent of age (i.e. occurrences uniformly distributed through the lineage's age)
point_estimates<-lapply(S,Sample,TE=TE,TS=TS,rr=rr,tmax=tmax)
} else{ #dependent of age (i.e. occurrences distributed through the lineage's age accourding to the function provided by the user)
point_estimates<-SampleADPP(S, TS=TS, TE=TE, rr=rr, dFUN = dFUN, dFUNmax = dFUNmax, ...)
}
#wrapping data:
if(!returnTrue){ # output as fossil occurrence binned within stages/bins
res<-data.frame(matrix(nrow=0, ncol=4))
colnames(res)<-c("Species", "Extant", "MaxT", "MinT")
for(i in 1:length(point_estimates)){
binned_occs<-binner(point_estimates[[i]], bins=stages)
for(k in 1:(length(stages)-1)){
if(binned_occs[k]>0){
# make a row of the data frame
aux<-data.frame(Species=i,Extant=NA,MaxT=rep(stages[k], times=binned_occs[k]),MinT=stages[k+1])
res<-rbind(res, aux)
}
}
}
# make the Extant column
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
# and the species column
res$Species<-paste0("spp_", res$Species)
} else{ # output as the "true" times of preservation of each lineage
# if returnTrue=TRUE, get a a data frame with the real sampling times only
res<-data.frame(matrix(nrow=length(unlist(point_estimates)), ncol=3))
colnames(res)<-c("Species", "Extant", "SampT")
res$Species<-rep(S, times=lapply(point_estimates, length))
res$Extant<-FALSE
res$Extant[res$Species %in% which(sim$EXTANT)]<-TRUE
res$Species<-paste0("spp_", res$Species)
res$SampT<-unlist(point_estimates)
}
return(res)
}
SampleClade(1, sim, 100, tmax=10, returnTrue=TRUE)
setwd("~/RESEARCH/Foote2019Research/Paleobuddy-all/PaleoBuddy")
check()
devtools::check()
library(devtools)
library(tidyverse)
library(fs)
create_package("~/Documents/RESEARCH/Foote2019Research/Paleobuddy-all/PaleoBuddy")
load_all()
library(devtools)
load_all()
document()
?check
check()
traceback()
document()
traceback()
?roclet_process
use_mit_license()
use_mit_license("Bruno do Rosario Petrucci")
check()
traceback()
check()
library(roxygen2)
check()
document()
traceback()
roclets
?roclets
?roxygenise
roxygenise()
traceback()
traceback(roclets=c("collate", "namespace", "rd"))
PaleoBuddy::BIC()
?BIC
traceback()
roxygenise()
traceback()
document()
library(devtools)
library(fs)
library(tidyverse)
check()
document()
check()
