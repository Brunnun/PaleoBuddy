#' library(RPANDA)
#' to use as an example, let us try temperature
#' data(InfTemp)
#'
#' ff <- function(t, env) {
#'   return(0.05*env)
#' }
#' r <- MakeRate(ff, env_f = InfTemp)
#' plot(1:50, r(1:50), type='l')
#'
#' we can also have a function that depends on both time AND temperature
#' ff <- function(t, env) {
#'   return(0.001*exp(0.1*t) + 0.05*env)
#' }
#' r <- MakeRate(ff, env_f = InfTemp)
#' plot(1:50, r(1:50), type='l')
#'
#' as mentioned above, we could also use ifelse() to construct a step function
#' that is modulated by temperature
#' ff <- function(t, env) {
#'   return(ifelse(t < 10, 0.1 + 0.01*env,
#'                 ifelse(t < 30, 0.2 - 0.005*env,
#'                        ifelse(t <= 50, 0.1 + 0.005*env, 0))))
#' }
#' r <- MakeRate(ff, env_f = InfTemp)
#' plot(1:50, r(1:50), type='l')
#'
MakeRate<-function(ff,tmax, env_f=NULL,fshifts=NULL) {
# may use this soon
nargs = ifelse(is.numeric(ff), length(ff), length(formals(ff)))
# let us first check for some errors
if (is.numeric(ff)) {
# if ff is constant, we should not see any env_f or fshifts
if (length(ff) == 1) {
if (!is.null(env_f) || !is.null(fshifts)) {
stop("constant rate with environmental variable or shifts")
} else {
return(Vectorize(function(t) ff))
}
}
# if length(ff) > 1 we have a rates vector, so we must have a shifts vector
else if (is.null(fshifts)) {
stop("rate vector supplied without a shift vector")
}
# if they are not the same size, we have a problem
else if (length(ff) != length(fshifts)) {
stop("rate vector and shifts vector must have the same length")
}
# if we have a rates vector and shifts vector, should not have env_f
else if (!is.null(env_f)) {
stop("rates and shifts supplied with environmental variable;
use ifelse()")
}
}
else if (!is.null(fshifts)) {
stop("shifts vector supplied without a rates vector")
}
else if (nargs > 1 || (nargs == 0 && !is.numeric(ff))) {
# ff should not have more than two arguments or less than 1
if (nargs > 2 || nargs == 0) {
stop("function can only depend on time and environmental var")
}
# if it has two, we must also have a non-null env_f
else if (nargs == 2) {
if (is.null(env_f)) {
stop("environmental function supplied with no environmental variable")
}
}
}
else if (nargs == 1 && !is.null(env_f)) {
stop("environmental variable supplied with one argument function")
}
# check if there are shifts - i.e. if the rate is a step function
if (!is.null(fshifts)){
flist<-ff
# if user gave a list from past to present, make it from present to past
if (fshifts[2] < fshifts[1]) {
fshifts<-tmax - fshifts
}
# create the step function
f<-function(t){
if (t<0){
return(0)
}
else {
# get the rate for this time by subtracting the shifts
# and finding where the subtraction is positive
return(flist[tail(which(t-fshifts>=0), n=1)])
}
}
# vectorize the function so we can integrate it
f <- Vectorize(f)
}
# if we want it to be dependent on environmental variables
else if (!is.null(env_f)){
# find degrees of freedom
df <- smooth.spline(x=env_f[,1], env_f[,2])$df
# now that we have the degrees of freedom, perform the spline
spline_result <- smooth.spline(env_f[,1],env_f[,2], df=df)
# use predict to find the rate at all times
env_func <- function(t){
predict(spline_result,t)$y
}
# make it a function of time only
f<-function(t){
return(ff(t,env_func(t)))
}
}
# otherwise it is either constant or a function of time, so return itself
else {
f <- ff
}
return(f)
}
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
#' Returns information of a simulated clade for general speciation and
#' extinction rates
#'
#' \code{BDSimGeneral} takes an initial number of species, speciation and
#' extinction rates (either functions of time or of time and some
#' environmental variable), a maximum simulation time and possibly a shape for
#' age-dependent speciation and/or extinction.
#'
#' @param \code{N0} initial number of species, usually 1. Good param to
#' tweak if one is observing a low sample size when testing.
#'
#' @param \code{pp} function to hold the speciation rate over time.
#' \code{BDSim} supplies this function with a \code{pp} ready to be used, so
#' that the only other information \code{BDSimGeneral} needs is a shape in case
#' the rate is to be age-dependent.
#'
#' @param \code{qq} similar to above, but for extinction rate.
#'
#' @param \code{tmax} ending time of simulation. Any species still living
#' after \code{tmax} is considered extant, and any species that would be
#' generated after \code{tmax} is not born.
#'
#' @param \code{sshape} shape param for the Weibull distribution for
#' age-dependent speciation. Default is 0, where \code{pp} will be considered a
#' time-dependent exponential rate. For \code{sshape != NULL}, \code{pp} will
#' be considered a scale, and \code{rexp_var} will draw a Weibull distribution
#' instead.
#'
#' @param \code{eshape} similar as above, but for extinction rate.
#'
#' @return a list of vectors, as follows
#'
#' \describe{
#' \item{\code{TE}}{list of extinction times, with -0.01 as the time of
#' extinction for extant species.}
#'
#' \item{\code{TS}}{list of speciation times, with tmax+0.01 as the time of
#' speciation for species that started the simulation.}
#'
#' \item{\code{PAR}}{list of parents. Species that started the simulation have
#' NA, while species that were generated during the simulation have their
#' parent's number. Species are numbered as they are born.}
#'
#' \item{\code{EXTANT}}{list of booleans representing whether a species is
#' extant.}}
#'
#' @author written by Bruno do Rosario Petrucci.
#'
#' @examples
#'
#' REMEMBER TO INVERT TE AND TS IN SIMMEAN()
BDSimGeneral<-function(N0,pp,qq,tmax,sshape=NULL,eshape=NULL){
# create vectors to hold times of speciation, extinction, parents and status
TS<-rep(-0.01,N0)
TE<-rep(NA,N0)
Parent<-rep(NA,N0)
is.extant<-rep(TRUE,N0)
# initialize species count
Scount<-1
# while we have species to be analyzed still
while (length(TE)>=Scount){
# get the time of speciation, or 0 if the species
# was there at the beginning
tNow<-ifelse(TS[Scount]<0,0,TS[Scount])
# find the waiting time using rexp_var - note that in rexp_var we only
# count t from tNow (to consider the rates as functions), so that
# now we need to subtract tNow
WaitTimeS<-ifelse(pp(tNow)>0,
rexp_var(1,pp,tNow,tmax,sshape,
ifelse(TS[Scount]<0,0,TS[Scount])),Inf)
WaitTimeE<-ifelse(qq(tNow)>0,
rexp_var(1,qq,tNow,tmax,eshape,
ifelse(TS[Scount]<0,0,TS[Scount])),Inf)
# if the time of extinction is after the end of the simulation, make it tmax
tExp<-min(tNow+WaitTimeE, tmax)
# while there are fast enough speciations before the species goes extinct,
while ((tNow+WaitTimeS)<=tExp){
# advance to the time of speciation
tNow<-tNow+WaitTimeS
# add new times to the vectors
TS<-c(TS,tNow)
TE<-c(TE,NA)
Parent<-c(Parent,Scount)
is.extant<-c(is.extant,TRUE)
# get a new speciation waiting time, and include it in the vector
WaitTimeS<-ifelse(pp(tNow)>0,
rexp_var(1,pp,tNow,tmax,sshape,
ifelse(TS[Scount]<0,0,TS[Scount])),Inf)
}
# reached the time of extinction
tNow<-tExp
# record extinction, and if species is extant make it more than tmax
TE[Scount]<-ifelse(tNow<tmax,tNow,tmax+0.01)
is.extant[Scount]<-ifelse(TE[Scount]>tmax,TRUE,FALSE)
# next species
Scount<-Scount+1
}
# now we invert TE and TS so time goes from tmax to 0
TE <- tmax - TE
TS <- tmax - TS
return(list(TE=TE,TS=TS,PAR=Parent,EXTANT=is.extant))
}
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
#' Returns a wait time for an exponential or weibull distribution with constant
#' or time-varying parameters
#'
#' \code(rexp_var) uses a rate (that could be constant or time-varying), a range
#' of time and optionally a shape for age dependent rates. It also takes a
#' number of waiting times to return. This can serve both for an exponential
#' distribution, and a weibull distribution with varying parameters.
#'
#' @param \code{n} the number of times to return. The default is 1, but
#' we allow for a higher \code{n} to be consistent with the \code{rexp}
#' function.
#'
#' @param \code{lambda} the rate parameter for the exponential
#' distribution. If shape is not NULL, \code{lambda} is a scale for the Weibull.
#' In both cases we allow for any time-varying function. If one wants a
#' constant, please use \code{lambda <- function(t) {return(constant)}}.
#'
#' @param \code{now} the current time. Needed so that we consider only the
#' interval between the current time and the maximum time for the time-varying
#' rate. Notice this does means the waiting time is >= \code{now}, so one must
#' subtract \code{now} from the waiting time when using it.
#'
#' @param \code{tmax} the simulation ending time. If the waiting time
#' would be too high, we return \code{2*tmax} to signify the event never
#' happens. The function only considers the rate between \code{now} and
#' \code{tmax}.
#'
#' @param \code{shape} the shape of a weibull distribution. If not NULL,
#' the distribution is taken to be a weibull. Otherwise, it is considered an
#' exponential.
#'
#' Notes: if \code{shape} is really low it may be impossible
#' for \code{uniroot} to find a root. Time-varying shape is implemented, but
#' not yet thoroughly tested.
#'
#' @param \code{TS} if shape is given, there must be a TS parameter to
#' account for the scaling between simulation and species time. Supplying one
#' without the other leads to an error.
#'
#' @param \code{fast} if set to FALSE, waiting times larger than the max
#' simulation time will not be thrown away. Needed when testing the function.
#'
#' @return a vector of waiting times for the exponential or weibull
#' distribution with the given rates.
#'
#' @author written by Bruno do Rosario Petrucci; the idea for calculating
#' an exponentially distributed variable t using \code{1-p = exp(t)} came from
#' \code{baseR}'s own \code{rexp} and \href{https://rdrr.io/cran/ape/f/}{APE}.
#'
#' @examples
#'
#' Note: to effectively test, you must comment out the safeguard against
#' finding \code{t} when \code{1-exp(-int(rate)) < p}, since this can bias the
#' results.
#'
#' use the \code{fitdistrplus} package to see if our distributions fit what we
#' expect
library(fitdistrplus)
#'
#' let us start by checking a simple exponential variable
lambda <- 0.1
now <- 0
tmax <- 40
dis <- rexp_var(n=10000, lambda, now, tmax, fast=FALSE)
rate <- unname(fitdist(dis, distr="exp")$estimate)
print(paste("rate: ",paste(rate, paste(", expected: ", lambda))))
#' another simple exponential
lambda <- 0.5
dis <- rexp_var(n=10000, lambda, now, tmax, fast=FALSE)
rate <- unname(fitdist(dis, distr="exp")$estimate)
print(paste("rate: ", paste(rate, paste(", expected: ", lambda))))
#'
#' now let us try a linear function
lambda <- function(t) {
return(0.01 * t + 0.1)
}
dis <- rexp_var(n=10000, lambda, now, tmax, fast=FALSE)
rate <- unname(fitdist(dis, distr="exp")$estimate)
#' we can integrate to find the mean rate
f <- Vectorize(function(t) {
ifelse(lambda(t) == Inf, 0,
exp(-integrate(function(x) lambda(x),
lower=0, upper=t, subdivisions=2000)$value))})
mean <- 1/integrate(f, 0, Inf)$value
print(paste("rate: ", paste(rate, paste(", expected: ", mean))))
#' and we can also integrate to find the mean directly
p <- Vectorize(function(t) {
return(
ifelse(lambda(t) == Inf, 0,
lambda(t)*exp(-integrate(Vectorize(
function(x) lambda(x)), lower=0, upper=t)$value))
)
})
mean<-integrate(function(t) t*p(t), 0, Inf)$value
print(paste("mean: ", paste(mean(dis), paste(", expected: ", mean))))
#'
#' what if lambda is exponential?
lambda <- function(t) {
return(0.01 * exp(0.1*t) + 0.02)
}
dis <- rexp_var(n=10000, lambda, now, tmax, fast=FALSE)
rate <- unname(fitdist(dis, distr="exp")$estimate)
f <- Vectorize(function(t) {
ifelse(lambda(t) == Inf, 0,
exp(-integrate(function(x) lambda(x),
lower=0, upper=t, subdivisions=2000)$value))})
mean <- 1/integrate(f, 0, Inf)$value
print(paste("rate: ", paste(rate, paste(", expected: ", mean))))
p <- Vectorize(function(t) {
return(
ifelse(lambda(t) == Inf, 0,
lambda(t)*exp(-integrate(Vectorize(
function(x) lambda(x)), lower=0, upper=t)$value))
)
})
mean <- integrate(function(t) t*p(t), 0, Inf)$value
print(paste("rate: ", paste(mean(dis), paste(", expected: ", mean))))
#'
#' now we can also test the age dependency
lambda <- 2
shape <- 1
dis <- rexp_var(n=5000, lambda, now, tmax, shape = shape, TS = 0, fast=FALSE)
e_shape <- unname(fitdist(dis, distr = "weibull")$estimate)[1]
e_scale <- unname(fitdist(dis, distr = "weibull")$estimate)[2]
print(paste("shape: ", paste(e_shape, paste(", expected: ", shape))))
print(paste("scale: ", paste(e_scale, paste(", expected: ", lambda))))
#'
#' shape = 1 is an exponential, we could do better
lambda <- 10
shape <- 2
dis <- rexp_var(n=10000, lambda, now, tmax, shape = shape, TS = 0, fast=FALSE)
e_shape <- unname(fitdist(dis, distr = "weibull")$estimate)[1]
e_scale <- unname(fitdist(dis, distr = "weibull")$estimate)[2]
print(paste("shape: ", paste(e_shape, paste(", expected: ", shape))))
print(paste("scale: ", paste(e_scale, paste(", expected: ", lambda))))
#'
#' fitdist gets a bit weird with shape less than 1, so we need some extra
#' arguments to get a fit
lambda <- 10
shape <- 0.5
dis <- rexp_var(n=10000, lambda, now, tmax, shape = shape, TS = 0, fast=FALSE)
e_shape <- unname(fitdist(dis, distr = "weibull", start=list(shape=1,scale=1),
method="mge", gof="CvM")$estimate)[1]
e_scale <- unname(fitdist(dis, distr = "weibull", start=list(shape=1,scale=1),
method="mge", gof="CvM")$estimate)[2]
print(paste("shape: ", paste(e_shape, paste(", expected: ", shape))))
print(paste("scale: ", paste(e_scale, paste(", expected: ", lambda))))
#'
#' when lambda and shape vary, we might need to do some more to test
lambda <- function(t) {
return(0.25*t + 5)
}
shape <- 3
dis <- rexp_var(n=5000, lambda, now, tmax, shape = shape, TS = 0, fast=FALSE)
#' we will integrate the distribution to find the mean directly
p <- Vectorize(function(t) {
res<-shape/lambda(t)*(integrate(
Vectorize(function(x) 1/lambda(x)), lower = 0, upper = t,
subdivisions=2000)$value)^(shape-1)*
exp(-(integrate(Vectorize(function(x) 1/lambda(x)), 0, t,
subdivisions=2000)$value)^shape)
# na simply means R doesn't know how to multiply 0 by infinity, but we just
# need to make it 0 since t*exp(-t) goes to 0 when t goes to infinity
return(res)
})
mean <- integrate(function(t) t*p(t), 0, Inf)$value
print(paste("rate: ", paste(mean(dis), paste(", expected: ", mean))))
#'
#' lambda can be any function of time, remember
lambda <- function(t) {
return(0.2*exp(0.1*t) + 5)
}
shape <- 3
dis <- rexp_var(n=10000, lambda, now, tmax, shape = shape, TS = 0, fast=FALSE)
p <- Vectorize(function(t) {
res<-shape/lambda(t)*(integrate(
Vectorize(function(x) 1/lambda(x)), lower = 0, upper = t,
subdivisions=2000)$value)^(shape-1)*
exp(-(integrate(Vectorize(function(x) 1/lambda(x)), 0, t,
subdivisions=2000)$value)^shape)
# na simply means R doesn't know how to multiply 0 by infinity, but we just
# need to make it 0 since t*exp(-t) goes to 0 when t goes to infinity
return(ifelse(is.na(res), 0, res))
})
mean <- integrate(function(t) t*p(t), 0, Inf)$value
print(paste("rate: ", paste(mean(dis), paste(", expected: ", mean))))
#'
rexp_var<-function(n=1, lambda, now, tmax, shape = NULL, TS = NULL, fast=TRUE){
# make a vector to hold the results
vars<-rep(0,n)
# default is not age dependent, will change this later
AD <- FALSE
# make lambda a function if it is a constant
l <- lambda
lambda <- ifelse(is.numeric(lambda),
function(t) {
return(l)
}, l)
# same for shape
if (!is.null(shape)) {
AD <- TRUE
s <- shape
shape <- ifelse(is.numeric(shape),
function(t) {
return(s)
}, s)
}
for (i in 1:n){
# draw an uniform random variable from 0 to 1
p<-runif(1)
if (AD){
# if it is age dependent, find the current species time
spnow<-now-TS
# calculate the probability that the event will happen at all
total <- 1-exp(-(integrate(
Vectorize(function(x) 1/lambda(x+TS)), lower=spnow, upper=tmax-TS,
subdivisions=2000)$value)^shape(tmax))
#if the probability is lower than p, the event will not happen
if (total<p & fast){
vars[i]<-2*tmax+0.01
}
else {
# create a function to hold the CDF of the distribution minus the
# uniform variable - if we find t where this is 0, this t is
# distributed as a weibull
f<-Vectorize(function(t) {
1-p-exp(-(integrate(
Vectorize(function(x) 1/lambda(x+TS)),lower=spnow,upper=t,
subdivisions=2000)$value)^shape(t))})
# finding the t where this is 0
vars[i]<-uniroot(f,c(spnow,tmax),extendInt="yes")$root-spnow
}
}
else {
# same as above but for an exponential variable
if (1-exp(-integrate(Vectorize(function(x) lambda(x)), lower=now,
upper=tmax, subdivisions=2000)$value)<p & fast){
vars[i]<-2*tmax+0.01
}
else{
# if f(t) = 0, t is exponentially distributed
f<-Vectorize(function(t) {
1-p-exp(-integrate(Vectorize(function(x) lambda(x)),lower=now,upper=t,
subdivisions=2000)$value)})
vars[i]<-uniroot(f,c(0,tmax),extendInt="yes")$root-now
}
}
}
return(vars)
}
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
sim
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
while(length(sim$TE) < 2){ #in case first simulation has only one species
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
}
sim
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
while(length(sim$TE) < 2){ #in case first simulation has only one species
sim<-BDSim(N0=1, pp=function(t) 0.1+0.01*t,qq=10, tmax=10, eshape=1.3)
}
sim
#'
#' this works for sim generated with any of the scenarios in \code{BDSim}, of course
sim<-BDSim(N0=1, pp=function(t) 0.12+0.01*t,qq=10, tmax=10, eshape=1.3)
while(length(sim$TE) < 2){ #in case first simulation has only one species
sim<-BDSim(N0=1, pp=function(t) 0.12+0.01*t,qq=10, tmax=10, eshape=1.3)
}
sim
plot.phylo(phy)
phy<-MakePhylo(sim)
plot.phylo(phy)
devtools::load_all("~/Documents/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy/")
devtools::load_all("~/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy/")
devtools::load_all("~/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy/R")
devtools::load_all("~/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy/R/")
library(devtools)
library(fs)
library(tidyverse)
create_package("~/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy")
create_package("~/Documents/RESEARCH/Foote2019Research/PaleoBuddy-all/PaleoBuddy")
