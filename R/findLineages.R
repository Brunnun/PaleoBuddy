#' Separate a paleobuddy simulation into monophyletic clades
#'
#' \code{findLineages} finds and separates monophyletic clades from simulations
#' generated by \code{BDSim} function. As a default, it finds the clades descended
#' from the starting species (i.e. those with no parent). It can also find the
#' clades descended from any species in \code{sim}. The result is a \code{sim}
#' object that also includes a vector keeping track of the original naming of
#' member species.
#'
#' @param sim a simulation from the \code{BDSim} function. The function accepts
#' simulations with any number of starting species.
#'
#' @param S a list of species in \code{sim}. If not supplied, \code{S} will be
#' the starting species in the simulation (i.e. those for which the parent is
#' \code{NA}).
#'
#' @author written by Bruno Petrucci and Matheus Januario.
#'
#' @return A \code{list} object with (named) \code{sim} objects corresponding to
#' the clades descended from species in S. For each clade, an extra list
#' \code{sim$LIN} is included so the user can identify the order of species
#' in the return with the order of species in the original simulation.
#'
#' @examples
#'
#' # we will start with examples where S are the starting species
#' 
#' # first, let us try a simulation with 3 clades,
#' sim<-BDSim(n0 = 3, pp = .1, qq = 0.1, tMax = 10)
#' 
#' # in case first simulation has a small number of lineages
#' while (length(sim$TE)<20) {
#'   sim<-BDSim(n0 = 3, pp = .1, qq = 0.1, tMax = 10)
#' }
#' 
#' # using the functions
#' test <- findLineages(sim)
#' 
#' # testing if it works:
#' par(mfrow=c(1,length(test)))
#' for (i in 1:length(test)) {
#'   if (sum(test[[i]]$PAR %in% i)<1) {
#'     plot(NA, xlim = c(-1,1), ylim=c(-1,1))
#'     text("simulation with \n just one lineage", x = 0, y=.5, cex=2)
#'   } else {
#'     if (requireNamespace("ape", quietly = TRUE)) {
#'       p=ape::plot.phylo(MakePhylo(test[[i]]),
#'                         main="red = extinction events \n blue = speciation events");
#'       ape::axisPhylo()
#'     }
#'     
#'     # checking speciation times:
#'     for (j in 2:length(test[[i]]$TS)) {
#'       # the subtraction is just to adjust the wt with the plot scale
#'       lines(x=c(
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TS[j],
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TS[j]),
#'         y=c(p$y.lim[1],p$y.lim[2]),lwd=2, col="blue")
#'     }
#'     
#'     # checking extinction times:
#'     for (j in 1:length(sim$TE)) {
#'       # the subtraction is just to adjust the wt with the plot scale
#'       lines(x=c(
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TE[j],
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TE[j]),
#'         y=c(p$y.lim[1],p$y.lim[2]),lwd=2, col="red")
#'     }
#'   }
#' }
#' 
#' # it works with any number of clades, of course
#' sim<-BDSim(n0 = 5, pp = .1, qq = 0.1, tMax = 10)
#' 
#' # in case first simulation has a small number of lineages
#' while (length(sim$TE)<20) {
#'   sim<-BDSim(n0 = 5, pp = .1, qq = 0.1, tMax = 10)
#' }
#' 
#' # using the functions
#' test <- findLineages(sim)
#' 
#' # testing if it works:
#' par(mfrow=c(1,length(test)))
#' for (i in 1:length(test)) {
#'   if (sum(test[[i]]$PAR %in% i)<1) {
#'     plot(NA, xlim = c(-1,1), ylim=c(-1,1))
#'     text("simulation with \n just one lineage", x = 0, y=.5, cex=2)
#'   } else {
#'     if (requireNamespace("ape", quietly = TRUE)) {
#'       p=ape::plot.phylo(MakePhylo(test[[i]]),
#'                         main="red = extinction events \n blue = speciation events");
#'       ape::axisPhylo()
#'     }
#'     
#'     # checking speciation times:
#'     for (j in 2:length(test[[i]]$TS)) {
#'       # the subtraction is just to adjust the wt with the plot scale
#'       lines(x=c(
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TS[j],
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TS[j]),
#'         y=c(p$y.lim[1],p$y.lim[2]),lwd=2, col="blue")
#'     }
#'     
#'     # checking extinction times:
#'     for (j in 1:length(sim$TE)) {
#'       # the subtraction is just to adjust the wt with the plot scale
#'       lines(x=c(
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TE[j],
#'         sort(test[[i]]$TS, decreasing = TRUE)[2]-test[[i]]$TE[j]),
#'         y=c(p$y.lim[1],p$y.lim[2]),lwd=2, col="red")
#'     }
#'   }
#' }
#' 
#' # including one clade, of course
#' sim<-BDSim(n0 = 1, pp = .2, qq = 0.1, tMax = 10)
#' while (length(sim$TE)<10) {
#'   sim<-BDSim(n0 = 1, pp = .1, qq = 0.1, tMax = 10)
#' }
#' 
#' 
#' par(mfrow=c(1,2))
#' if (requireNamespace("ape", quietly = TRUE)) {
#'   ape::plot.phylo(MakePhylo(sim), main="original")
#'   ape::axisPhylo()
#'   ape::plot.phylo(MakePhylo(findLineages(sim)[[1]]), main="after findLineages()")
#'   ape::axisPhylo()
#'   #those should be equal
#' }
#' 
#' # now let us check that when S does not contain a starting species, we still
#' # get correct subsets of the simulation
#' sim <- BDSim(1, 0.1, 0.05, 40)
#' # making sure we have a couple of clades to explore
#' while ((length(which(sim$PAR==1)) < 3) | (length(which(sim$PAR==2)) < 3) |
#'        (length(which(sim$PAR==3)) < 3)) {
#'   sim <- BDSim(1, 0.2, 0.1, 10)
#' }
#' 
#' if (requireNamespace("ape", quietly = TRUE)) {
#'   # first we plot the clade started by 1
#'   ape::plot.phylo(MakePhylo(sim), main="original")
#'   
#'   # this should look the same
#'   ape::plot.phylo(MakePhylo(findLineages(sim)[[1]]), main="after findLineages()")
#'   
#'   # and these should be part of the previous phylogenies
#'   ape::plot.phylo(MakePhylo(findLineages(sim, c(2, 3))$clade_2), 
#'                   main = "Clade_2")
#'   ape::plot.phylo(MakePhylo(findLineages(sim, c(2, 3))$clade_3),
#'                   main = "Clade_3")
#' }
#' 
#' @name findLineages
#' @rdname findLineages
#' @export

findLineages <- function(sim, S = NULL) {
  # if S is null, the user wants to find the lineages with the simulation's
  # starting species as parents
  if (is.null(S)) {
    # by convention, species without parents in the output of the BD functions
    # have parents set to NA
    S = which(is.na(sim$PAR))
  }

  # create a final list
  final <- list()

  # find lineages for each species
  for (s in S) {
    # name the clade, and use the helper function below to find the species
    # descended from s for each s in S
    final[[paste0("clade_", s)]] = findLineage(sim, s)
  }
  return(final)
}

#' Helper function for findLineages
#'
#' \code{findLineage} takes a simulation object, usually from \code{BDSim},
#' and a species number, and returns the simulation object that has that
#' species as a common ancestor.
#'
#' @param sim a simulation from the \code{BDSim} function. The
#' function accept simulations with any number of starting species.
#'
#' @param s a species number. The function will return a sim object whose common
#' ancestor is the species s, and s will be renumbered to species 1 in the result.
#'
#' @author written by Bruno Petrucci.
#'
#' @return a \code{sim} object with \code{s} as the mother species, including
#' all descendants of \code{s}. An extra list \code{sim$LIN} is included so the
#' user can identify the order of species in the return with the order of species
#' in the original simulation.
#'

findLineage <- function(sim, s) {
  # if s is not on the simulation, we have a problem
  if (s > length(sim$TE)) {
    stop("This species is not on the simulation")
  }

  # lineage starts with a species
  lin <- c(s)

  # daughters of the first species of the lineage
  dau <- which(sim$PAR == s)

  # while species in the lineage have daughters
  while (length(dau) > 0) {
    # append the daughters to the lineage
    lin <- c(lin, dau)

    # find the daughters of the previous daughters
    dau <- which(sim$PAR %in% dau)
  }

  # make vectors for the clade
  TE <- sim$TE[lin]
  TS <- sim$TS[lin]
  PAR <- sim$PAR[lin]
  EXTANT <- sim$EXTANT[lin]

  # PAR here still follows the identifications on the original sim, so we need
  # to rename the species
  if (length(PAR)>1) {
    # if the first species is not already unparented, it will be now
    PAR[1] = NA

    # first species of the clade (the one that generated the second) is 1
    PAR[PAR==PAR[2]] = 1

    # every other species follows the order in lin, to preserve the order
    # of TE and TS
    for (p in unique(PAR[PAR != 1 & !is.na(PAR)])) {
      PAR[PAR == p] = which(lin == p)
    }
  }

  # append it to a sim
  # note the inclusion of lin - this way, a user can tell which species in sim1
  # corresponded to which species in sim
  sim1 <- list(TE = TE, TS = TS, PAR = PAR, EXTANT = EXTANT, LIN = lin)

  return(sim1)
}
